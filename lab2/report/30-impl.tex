\chapter*{Общая для всех вариантов программа}

\section*{Исследуемая программа}

Исходный текст исследуемой программы  представлен на листинге \ref{list_source}.

\begin{lstlisting}[caption=Исходный текст общей программы,
	label={list_source}]
.section .text (1)
.globl _start; (2)
len = 8 # size of array (3)
enroll = 4 #amount of processed elements in one iteration
elem_sz = 4 #size of one element in array
_start: (4)
addi x20, x0, len/enroll (5)
la x1, _x (6)
loop:
lw x2, 0(x1) (7)
add x31, x31, x2 (8)
lw x2, 4(x1)
add x31, x31, x2
lw x2, 8(x1)
add x31, x31, x2
lw x2, 12(x1)
add x31, x31, x2
addi x1, x1, elem_sz*enroll (9)
addi x20, x20, -1 (10)
bne x20, x0, loop (11)
addi x31, x31, 1
forever: j forever (12)

.section .data (13)
_x:     .4byte 0x1 (14)
.4byte 0x2
.4byte 0x3
.4byte 0x4
.4byte 0x5
.4byte 0x6
.4byte 0x7
.4byte 0x8
\end{lstlisting}

\clearpage
Дизассемблерный листинг исследуемой программы  представлен на листинге \ref{list_disasm}.


\begin{lstlisting}[caption=Дизассемблерный листинг общей программы,
	label={list_disasm}]
	80000000 <_start>:
	80000000:	00200a13          	addi	x20,x0,2
	80000004:	00000097          	auipc	x1,0x0 (1)
	80000008:	03c08093          	addi	x1,x1,60 # 80000040 <_x>
	
	8000000c <loop>:
	8000000c:	0000a103          	lw	x2,0(x1)
	80000010:	002f8fb3          	add	x31,x31,x2
	80000014:	0040a103          	lw	x2,4(x1)
	80000018:	002f8fb3          	add	x31,x31,x2
	8000001c:	0080a103          	lw	x2,8(x1)
	80000020:	002f8fb3          	add	x31,x31,x2
	80000024:	00c0a103          	lw	x2,12(x1)
	80000028:	002f8fb3          	add	x31,x31,x2
	8000002c:	01008093          	addi	x1,x1,16
	80000030:	fffa0a13          	addi	x20,x20,-1
	80000034:	fc0a1ce3          	bne	x20,x0,8000000c <loop>
	80000038:	001f8f93          	addi	x31,x31,1
	
	8000003c <forever>:
	8000003c:	0000006f          	jal	x0,8000003c <forever>
\end{lstlisting}

\clearpage
Можно сказать, что данная программа эквивалентна псевдокоду на языке C, представленному на листинге \ref{list_psevdo}.


\begin{lstlisting}[caption=Псевдокод общей программы,
	label={list_psevdo}]
#define len 8
#define enroll 4
#define elem_sz 4
int _x[]={1,2,3,4,5,6,7,8};
void _start() {
	int x20 = len/enroll;
	int *x1 = _x;
	
	do {
		int x2 = x1[0];
		x31 += x2;
		x2 = x1[1];
		x31 += x2;
		x2 = x1[2];
		x31 += x2;
		x2 = x1[3];
		x31 += x2;
		x1 += enroll;
		x20--;
	} while(x20 != 0);
	x31++;
	while(1){}
}
\end{lstlisting}


\chapter*{Результаты исследования программы}

Все задания выполнялись по индивидуальному варианту (6).

Скриншот, полученный в ходе выполнения задания №2 (получить снимок экрана, содержащий временную диаграмму выполнения стадий выборки и диспетчеризации команды с адресом 80000020 на первой итерации) представлен на рисунке \ref{img:task2}.

\img{110mm}{task2}{Временная диаграмма выполнения стадий выборки и диспетчеризации}

\clearpage
Скриншот, полученный в ходе выполнения задания №3 (получить снимок экрана, содержащий временную диаграмму выполнения стадии декодирования и планирования на выполнение команды с адресом 8000002с на первой итерации) представлен на рисунке \ref{img:task3}.

\img{110mm}{task3}{Временная диаграмма выполнения стадии декодирования и планирования на выполнение}

\clearpage
Скриншот, полученный в ходе выполнения задания №4 (получить снимок экрана, содержащий временную диаграмму выполнения стадии выполнения команды с адресом 80000014 на первой итерации) представлен на рисунке \ref{img:task4}.

\img{110mm}{task4}{Временная диаграмма выполнения стадии выполнения}



\chapter*{Программа по варианту}

Все задания выполнялись по индивидуальному варианту (6).

\section*{Исследуемая программа}

Исходный текст исследуемой программы  представлен на листинге \ref{list_source2}.

\begin{lstlisting}[caption=Исходный текст исследуемой программы,
	label={list_source2}]
	.section .text
	.globl _start;
	len = 8 # size of array 
	enroll = 2 #amount of processed elements in one iteration
	elem_sz = 4 #size of one element in array
	
	_start:
	addi x20, x0, len/enroll
	la x1, _x
	lp:
	lw x2, 0(x1)
	lw x3, 4(x1) #!
	addi x1, x1, elem_sz*enroll
	addi x20, x20, -1
	add x31, x31, x2
	add x31, x31, x3
	bne x20, x0, lp
	addi x31, x31, 1
	lp2: j lp2
	
	.section .data
	_x:     .4byte 0x1
	.4byte 0x2
	.4byte 0x3
	.4byte 0x4
	.4byte 0x5
	.4byte 0x6
	.4byte 0x7
	.4byte 0x8
\end{lstlisting}

\clearpage
Дизассемблерный листинг исследуемой программы  представлен на листинге \ref{list_disasm2}.


\begin{lstlisting}[caption=Дизассемблерный листинг исследуемой программы,
	label={list_disasm2}]
	80000000 <_start>:
	80000000:       00400a13                addi    x20,x0,4
	80000004:       00000097                auipc   x1,0x0
	80000008:       02c08093                addi    x1,x1,44 # 80000030 <_x>
	
	8000000c <lp>:
	8000000c:       0000a103                lw      x2,0(x1)
	80000010:       0040a183                lw      x3,4(x1)
	80000014:       00808093                addi    x1,x1,8
	80000018:       fffa0a13                addi    x20,x20,-1
	8000001c:       002f8fb3                add     x31,x31,x2
	80000020:       003f8fb3                add     x31,x31,x3
	80000024:       fe0a14e3                bne     x20,x0,8000000c <lp>
	80000028:       001f8f93                addi    x31,x31,1
	
	8000002c <lp2>:
	8000002c:       0000006f                jal     x0,8000002c <lp2>
\end{lstlisting}

\clearpage
Можно сказать, что данная программа эквивалентна псевдокоду на языке C, представленному на листинге \ref{list_psevdo2}.


\begin{lstlisting}[caption=Псевдокод исследуемой программы,
	label={list_psevdo2}]
	#define len 8
	#define enroll 2
	#define elem_sz 4
	int _x[]={1,2,3,4,5,6,7,8};
	void _start() {
		int x20 = len/enroll;
		int *x1 = _x;
		
		do {
			int x2 = x1[0];
			int x3 = x1[1];
			x1 += enroll;
			x20--;
			x31 += x2;
			x31 += x3;
		} while(x20 != 0);
		x31++;
		while(1){}
	}
\end{lstlisting}

\section*{Трасса работы программы}

Трасса работы программы представлена на рисунке \ref{img:trassa1}.

\clearpage
\img{110mm}{trassa1}{Трасса работы программы}

\section*{Временные диаграммы}

Временные диаграммы сигналов, соответствующих всем стадиям выполнения команды, обозначенной в тексте программы символом \#! (80000010:	0040a183	lw x3,4(x1)), представлены на рисунке \ref{img:forhash}.

\clearpage
\img{110mm}{forhash}{Временные диаграммы сигналов}


\section*{Вывод об эффективности работы программы}

Как видно на трассе работы программы, представленой на рисунке \ref{img:trassa1}, конфликта по регистрам не возникает ни разу, и все команды принимаются на исполнение сразу же по готовности. Это обеспечивается продуманным чередованием команд обращения к памяти и арифметических команд.

Можно также заметить, что трижды возникает ситуация ошибочной выборки, которая крайне негативно сказывается на производительности, так как приводит к необходимости очистки конвеера, и ожидания прохождения новой команы по всем стадиям работы. Однако, учитывая большое количество ветвлений в данной программе (только сам цикл повторяется 4 раза), можно сказать, что предсказаель ветвлений ошибается не слишком часто.

Оптимизировать же программу можно, уменьшив количество циклов в ней. В исходном коде цикл повторяется 4 раза, и некоторые команды, не относящиеся напрямую к вычислению суммы элементов массива (во-первых, команда условного перехода bne x20, x0, lp; во-вторых, декремент счетчика цикла addi x20, x20, -1; в-третьих, смещение указателя на начало массива: addi x1, x1, elem\_sz*enroll) повторяются 4 раза. 

Если же уменьшить количество циклов до двух (за счет увеличения количества обрабатываемых элементов массива за одну итерацию до 4), то эти команды выполнятся всего 2 раза. При правильной и продуманной последовательности операций обращения к памяти и выполнения арифметических вычисслений, все еще удастся избежать конфликтов по регистрам. 

В итоге можно обеспечить выигрыш в 3*2=6 тактов, и оптимизированная программа будет работать на 6/49=13\% бысрее.


\section*{Оптимизированная программа}

Исходный текст оптимизированной программы  представлен на листинге \ref{list_source3}.

\begin{lstlisting}[caption=Исходный текст оптимизированной программы,
	label={list_source3}]
	        .section .text
	.globl _start;
	len = 8 
	enroll = 4 
	elem_sz = 4
	
	_start:
	addi x20, x0, len/enroll
	la x1, _x
	lp:
	lw x2, 0(x1)
	lw x3, 4(x1) #!
	addi x20, x20, -1
	add x31, x31, x2
	add x31, x31, x3
	
	lw x2, 8(x1)
	lw x3, 12(x1)
	addi x1, x1, elem_sz*enroll
	add x31, x31, x2
	add x31, x31, x3
	
	bne x20, x0, lp
	addi x31, x31, 1
	lp2: j lp2
	
	.section .data
	_x:     .4byte 0x1
	.4byte 0x2
	.4byte 0x3
	.4byte 0x4
	.4byte 0x5
	.4byte 0x6
	.4byte 0x7
	.4byte 0x8
\end{lstlisting}

\clearpage
Дизассемблерный листинг оптимизированной программы  представлен на листинге \ref{list_disasm3}.


\begin{lstlisting}[caption=Дизассемблерный листинг оптимизированной программы,
	label={list_disasm3}]
	80000000 <_start>:
	80000000:       00200a13                addi    x20,x0,2
	80000004:       00000097                auipc   x1,0x0
	80000008:       03c08093                addi    x1,x1,60 # 80000040 <_x>
	
	8000000c <lp>:
	8000000c:       0000a103                lw      x2,0(x1)
	80000010:       0040a183                lw      x3,4(x1)
	80000014:       fffa0a13                addi    x20,x20,-1
	80000018:       002f8fb3                add     x31,x31,x2
	8000001c:       003f8fb3                add     x31,x31,x3
	80000020:       0080a103                lw      x2,8(x1)
	80000024:       00c0a183                lw      x3,12(x1)
	80000028:       01008093                addi    x1,x1,16
	8000002c:       002f8fb3                add     x31,x31,x2
	80000030:       003f8fb3                add     x31,x31,x3
	80000034:       fc0a1ce3                bne     x20,x0,8000000c <lp>
	80000038:       001f8f93                addi    x31,x31,1
	
	8000003c <lp2>:
	8000003c:       0000006f                jal     x0,8000003c <lp2>
\end{lstlisting}

\section*{Трасса работы программы}

Трасса работы оптимизированной программы представлена на рисунке \ref{img:trassa2}.

\img{110mm}{trassa2}{Трасса работы оптимизированной программы}



\clearpage